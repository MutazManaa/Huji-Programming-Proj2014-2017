import os
import time
from PIL import Image
import matplotlib.pyplot as plt
import nibabel as nib
import numpy as np
from scipy import ndimage
from scipy.spatial import ConvexHull
from skimage import morphology
from skimage import measure
import PIL.ImageOps 
import glob
import math

def multipleSeedRG(CTFile, ROIFile):
	'''Function implement the multi seeds region grow algorithm from given CT scan ROI.'''
	CT = nib.load(CTFile)
	CTScan = CT.get_data()
	ROI = nib.load(ROIFile)
	ROIScan = ROI.get_data()	
	segmentMatrix = np.zeros(CTScan.shape).astype(np.bool)
	visited = np.zeros(CTScan.shape).astype(np.bool)
	labeled = np.zeros(CTScan.shape).astype(np.bool)
	indices = np.where(ROIScan != 1)
	CTScan[indices] = 0
	# now get the values between 200 and 1300
	goodIndicies = np.where(np.bitwise_and(CTScan >= 200, CTScan <= 1300) == True)
	#print goodIndicies[0].shape
	# get 200 random point:

	neighbourSeg = np.zeros((3,3,3)).astype(np.bool)	
	randomPoints = np.random.choice(np.arange(goodIndicies[0].size), size=200, replace=False)
	Voxels = []
	#print randomPoints.shape
	#print randomPoints	
	
	for i in xrange(0,200):
		x = goodIndicies[0][randomPoints[i]]
		y = goodIndicies[1][randomPoints[i]]
		z = goodIndicies[2][randomPoints[i]]
		Voxels.append([x,y,z])
		
	
	while Voxels:
		x = Voxels[0][0]
		y = Voxels[0][1]
		z = Voxels[0][2]
		visited[x][y][z] = 1
		neighbourMatrix = CTScan[x-1:x+2,y-1:y+2,z-1:z+2]
		labelTemp = labeled[x-1:x+2,y-1:y+2,z-1:z+2]
		neighbourMean = np.mean(neighbourMatrix)
		neighbourStd = np.std(neighbourMatrix)	
		T = math.fabs((CTScan[x][y][z] - neighbourMean)/ neighbourStd)
		Temp = np.full((neighbourMatrix.shape),CTScan[x][y][z]) 
		neighbourMatrix = np.absolute(np.subtract(neighbourMatrix ,Temp))
		neighbourSeg = np.bitwise_and(neighbourMatrix < T, labelTemp == 0).astype(np.bool)
		#neighbourSeg = np.bitwise_and(neighbourMatrix >= 200,neighbourMatrix <= 1300).astype(np.bool)
		segmentMatrix[x-1:x+2,y-1:y+2,z-1:z+2] = np.bitwise_or(neighbourSeg,labelTemp)
		labeled[x-1:x+2,y-1:y+2,z-1:z+2] = 1
		goodneighbours = np.where(seg[x-1:x+2,y-1:y+2,z-1:z+2] != 0)
		
		for index in xrange(0,len(goodneighbours[0])):
			if goodneighbours[0][index] == 0: r = x-1 
			elif goodneighbours[0][index] == 1: r = x 
			else: r = x+1
			if goodneighbours[1][index] == 0: c = y-1 
			elif goodneighbours[1][index] == 1: c = y 
			else: c = y+1
			if goodneighbours[2][index] == 0: d = z-1 
			elif goodneighbours[2][index] == 1: d = z
			else: d = z+1
			if visited[r,c,d] == 0 and (0< r < CTScan.shape[0] -1) and (0 < c < CTScan.shape[1] -1) and (0 < d < CTScan.shape[2] -1):
				Voxels.append([r,c,d])
				
		Voxels.pop(0)		
	print np.count_nonzero(segmentMatrix)
	#print seg.nonzero().shape
	
	labels, count = measure.label(segmentMatrix, connectivity=2, return_num=True)
	sortLabels = sorted([np.sum(labels == i) for i in xrange(1, count + 1)])
	segmentMatrix = morphology.remove_small_objects(segmentMatrix == 1, min_size=sortLabels[-1], connectivity=2)
	imageToSave = nib.Nifti1Image(segmentMatrix.astype(np.int8), CT.affine)
	nib.save(imageToSave,"Case1_CT_RG.nii.gz")



def segmentBones(CTFile, AortaFile, outputFile,ROIFile):
	'''Function implementent bones segmentation from CT scan and Aorta segmentaion and given ROI'''
	Aorta = nib.load(AortaFileName)
	AortaData = aorta.get_data()
	#segmentMatrix = multipleSeedRG(ctFileName, roi_file_image)
	Bones = nib.load("Bone.nii.gz")
	segmentMatrix = Bones.get_data()
	#print segmentMatrix.nonzero()
	AortaData = ndimage.binary_dilation(AortaData, iterations=3)
	segmentMatrix[np.where(AortaData == 1)] = 0
	segmentMatrix = ndimage.binary_opening(segmentMatrix, iterations=2)
	labels, count = measure.label(segmentMatrix, connectivity=2, return_num=True)
	sortLabels = sorted([np.sum(labels == i) for i in xrange(1, count + 1)])
	segmentMatrix = morphology.remove_small_objects(segmentMatrix == 1, min_size=sortLabels[-1], connectivity=2)
	segmentMatrix = ndimage.binary_fill_holes(segmentMatrix)
	imageToSave = nib.Nifti1Image(imageToSave.astype(np.int8), Aorta.affine)
	nib.save(imageToSave, outputFile)
	

def evaluateSegmentation(groundTruthFile, RGFile):
	'''
 		The function calculate the overlap percentage between ground truth scan and the scan generated by the algorithm RG.
	'''
	gr = nib.load(groundTruthFile)
	grounTruth = gr.get_data()
	RG = nib.load(RGFile)
	regionGrown = RG.get_data()
	
	GTxRange = [min(np.where(grounTruth == 1)[0]),max(np.where(grounTruth == 1)[0])]
	GTyRange = [min(np.where(grounTruth == 1)[1]),max(np.where(grounTruth == 1)[1])]
	GTzRange = [min(np.where(grounTruth == 1)[2]),max(np.where(grounTruth == 1)[2])]
	RGxRange = [min(np.where(regionGrown == 1)[0]),max(np.where(regionGrown == 1)[0])]
	RGyRange = [min(np.where(regionGrown == 1)[1]),max(np.where(regionGrown == 1)[1])]
	RGzRange = [min(np.where(regionGrown == 1)[2]),max(np.where(regionGrown == 1)[2])]
	
	GTResult = np.zeros((grounTruth.shape),dtype=np.bool)
	GTResult[GTxRange[0]:GTxRange[1],GTyRange[0]:GTyRange[1],GTzRange[0]:GTzRange[1]] = 1
	RGResult = np.zeros((grounTruth.shape),dtype=np.bool)
	RGResult[RGResult[0]:RGResult[1],RGResult[0]:RGResult[1],RGResult[0]:RGResult[1]] = 1
	
	result = np.bitwise_and(GTResult,RGResult).astype(np.bool)
	overlapPercent = float(np.count_nonzero(result)/np.count_nonzero(GTResult))
	return overlapPercent
multipleSeedRG("Case1_CT.nii.gz", "Case1_CT_ROI.nii.gz")
#segmentBones("Case1_CT.nii.gz", "Case1_Aorta.nii.gz", "Case1_CT_SegBones.nii.gz","Case1_CT_ROI.nii.gz")
#def evaluateSegmentation()

